#!/usr/bin/env python3
"""Utility for deleting generated demo data and cleaning persistent volumes.

Running the demo creates a handful of bind-mounted folders on the host
filesystem so that Spark, HDFS, and the dashboards can share files. This
script removes the generated content from those directories so that the demo
can start from a completely clean slate without stale checkpoints or Parquet
files consuming disk space.
"""

from __future__ import annotations

import argparse
import shutil
from pathlib import Path
from typing import Iterable

# Paths that accumulate data as the demo runs. The directories themselves are
# intentionally kept so Docker bind mounts continue to work after cleanup.
REPO_ROOT = Path(__file__).resolve().parent

CLEANUP_PATHS: dict[str, Path] = {
    "Batch input CSVs": REPO_ROOT / "data" / "input",
    "Batch & streaming outputs": REPO_ROOT / "data" / "output",
    "HDFS NameNode volume": REPO_ROOT / "hdfs" / "namenode",
    "HDFS DataNode volume": REPO_ROOT / "hdfs" / "datanode",
    "Structured Streaming checkpoints": REPO_ROOT / "checkpoints",
    "Spark event logs": REPO_ROOT / "spark-events",
}


def ensure_directory(path: Path) -> None:
    """Ensure ``path`` exists as a directory, deleting files if necessary."""

    if path.exists() and not path.is_dir():
        path.unlink()
    path.mkdir(parents=True, exist_ok=True)


def clear_directory(path: Path) -> None:
    """Delete all contents under ``path`` while keeping the directory itself.

    The directory is created if it does not already exist so that Docker bind
    mounts defined in docker-compose files continue to function after cleanup.
    """

    ensure_directory(path)

    for entry in path.iterdir():
        if entry.is_dir():
            shutil.rmtree(entry)
        else:
            entry.unlink()


def perform_cleanup(paths: Iterable[tuple[str, Path]], *, dry_run: bool) -> None:
    for label, path in paths:
        if dry_run:
            print(
                f"[DRY RUN] Would clear '{path.relative_to(REPO_ROOT)}' ({label})"
            )
            continue

        if not path.exists():
            ensure_directory(path)
            print(
                f"Created missing directory '{path.relative_to(REPO_ROOT)}'"
                f" ({label})"
            )
            continue

        clear_directory(path)
        print(f"Cleared '{path.relative_to(REPO_ROOT)}' ({label})")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Delete data generated by the retail transactions demo so the"
            " attached volumes start fresh."
        )
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Only print what would be deleted without removing anything.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    perform_cleanup(CLEANUP_PATHS.items(), dry_run=args.dry_run)


if __name__ == "__main__":
    main()
